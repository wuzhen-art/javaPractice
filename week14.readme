
JVM
Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。
对象分配规则
对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。
GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。
标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
垃圾回收器
Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法
CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征

NIO
当客户端连接时，通过ServerSocketChannel得到SocketChannel
将socketChannel注册到Selector上， (register(Selector sel, int ops))，一个Selector可以注册多个socketChannel；参数ops是事件(读、写、连接)
注册后返回selectionKey,会和Selector关联(集合)
Selector进行监听 select方法，返回有事件发生的通道的个数
进一步得到各个selectionKey（有事件发生的）
通过selectionKey反向获取SocketChannel
完成SokectChannel上的业务处理
零拷贝是指没有cpu靠背 (操作系统的角度看的)
mmap 和 sendFile 的区别
mmap 适合小数据量读写，sendFile 适合大文件传输。
mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。
sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。


并发编程
线程和进程的区别
进程是一个可执行的程序，是系统分配资源的基本单位。线程是进程内部相对独立的可执行单元，是任务调度的基本单位。
多线程的优缺点
优点：充分利用多核CPU的优势，提高CPU的利用率和程序运行效率
缺点：1、线程过多影响性能，CPU切换增加内存开销。2、存在线程同步和线程安全问题。3、可能会发生死锁。4、增加了开发人员的技术难度
线程有几种状态
5种状态：新建，就绪，运行，阻塞和死亡。
新建状态：new创建一个线程时，还没开始运行，就是新建状态。
就绪状态：新建后，调用start()方法，线程就处于就绪态，等待CPU调度。
运行状态：当线程获得了CPU时间后，进入运行状态，执行run()里的内容
阻塞状态：线程运行中随时可能被阻塞：比如调用sleep()方法；等待获取锁被阻塞；线程在等待其他触发条件。暂时让出CPU资源。
死亡状态：有两个原因导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法

一个线程OOM了，其他线程是否还能运行
答案是还能运行，虽然堆是共享的，一个线程OOM了，可能说明其他线程也会OOM。但是当一个线程OOM了，它所占据的空间会立刻释放掉，从而不会影响其他线程的运行。另外，如果主线程异常了，子线程也可以运行。线程不像进程，一个进程之间的线程没有父子之分，都是平级关系。
创建线程的几种方法
继承Thread类，重写run()方法，利用Thread.start()启动线程
实现Runnable接口，重写run()方法，利用new Thread(Runnable a)创建线程，调用start()方法启动线程。
通过Callable和futureTask创建线程，实现Callable接口，重写call方法，利用future对象包装callable实例，通过Thread方法创建线程。
通过线程池创建线程
sleep和wait
wait只能在synchronized中调用，属于对象级别的方法，sleep不需要，属于Thread的方法。
调用wait方法会释放锁，sleep不会释放锁
wait超时之后线程进入就绪状态，等待获取cpu继续执行。
yield和join
yield会释放cpu资源，不会释放锁，让当前线程进入就绪状态，只能使同优先级或更高优先级的线程有执行的机会。
join会释放cpu资源和锁，底层是wait()方法实现的，join会等待调用join()方法的线程执行完成之后再继续执行。
死锁定义
死锁是指两个及以上的线程在执行过程中，因争夺资源而造成的一种互相等待（饥饿）的现象。若无外力作用，他们都将无法运行下去
死锁原因

系统资源的争夺：系统中拥有不可剥夺的资源，其数量不足以满足多个线程运行的需要，使得线程在运行过程因为争夺资源而陷入僵局。
线程推进顺序非法：线程在获得一个锁L1的情况下再去申请另一个锁L2，也就是在没有释放锁L1的情况下又去申请锁L2，这个是产生死锁最根本的原因。

死锁的必要条件

互斥条件：进程要求对所分配的资源在一段时间内只能由一个进程拥有。
不可剥夺条件：资源在进程未使用完成之前，不能被其他进程夺走，除非是主动释放
请求和保持条件：进程已经保持了一个资源，又去申请另一个资源，但是该资源已经被其他进程占有。
循环等待条件：进程资源循环等待，A拥有资源1，申请资源2，B拥有资源2，申请资源1

如何避免死锁

加锁顺序要合理
加锁时限要适当：线程尝试获取锁要加上一定时限，超时就要放弃请求，同时释放自己的锁。
死锁检测
Spring 和 ORM 等框架
MySQL 数据库和 SQL
分库分表
RPC 和微服务
分布式缓存
分布式消息队列
