# 主要GC类型

### 串行GC

- 单线程
  \- GC时，启动STW机制
  \- 适用于单核 CPU 小型（占用内存1G内）的应用
- `-XX:+UseSerialGC`，年轻代使用的是 mark-copy (标记-复制) 算法，老年代使用的是 mark-sweep-compact (标记-清除-整理) 算法，CPU利用率高，只能使用单核

### 并行GC

- 多线程的垃圾收集器
  \- GC时，启动STW机制，但多个线程并行地进行垃圾收集
  \- 适用于多核 CPU 的服务
- `-XX:+UseParellelGC`，年轻代使用的是 mark-copy (标记-复制) 算法，老年代使用的是 mark-sweep-compact (标记-清除-整理) 算法

### CMSGC

- 多线程的垃圾收集器
  \- 老年代采取分阶段的GC，只在“初始标记”和“最终标记”阶段会触发 STW，其余阶段不处罚STW，减少老年代 STW 的暂停时间
  \- 年轻代仍然采用并行 STW 方式进行 GC

  -适用于多核 CPU 的服务器，并且主要调优目标是降低 GC 停顿导致的系统延迟

- `-XX:+UseConcMarkSweepGC`，，MinorGC：年轻代采用并行 STW 方式的 mark-copy (标记-复制) 算法，年轻代进行垃圾收集时，会触发全线程的暂停 (Stop-The-World)，停止所有应用线程，MajorGC：老年代主要使用并发 mark-sweep (标记-清除) 算法，拆分成了多个阶段，其中两个阶段会触发 STW，其他阶段都会和应用线程一起执行。

  六阶段：阶段1：Initial Mark（初始标记）【STW】该阶段将标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）；

  阶段2：Concurrent Mark（并发标记）该阶段 CMS GC 遍历老年代，标记所有的存活对象，从前一阶段“Initial Mark”找到的根对象开始算起，“并发标记”阶段，就是与应用程序同时运行；

  阶段3：Concurrent Preclean（并发预清理）该阶段同样是与应用线程并发执行的，不需要停止应用线程。因为前一阶段 “并发标记” 与应用程序并发运行，可能有一些引用关系已经发生了改变，如果在“并发标记”过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记（Card Marking）

  阶段4：Final Mark（最终标记）【STW】本阶段的目标是完成老年代中所有存活对象的标记，因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度，该阶段伴随STW，也是此次 GC 事件中的最后一次，暂停下来，处理各种复杂的情况，通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件

  阶段5：Concurrent Sweep（并发清除）该阶段与应用程序并发执行，不需要 STW 停顿，JVM 在此阶段删除不再使用的对象，并回收它们占用的内存空间

  阶段6：Concurrent Reset（并发重置）该阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备

### G1GC

- 多线程的垃圾收集器
  \- 堆的内存结构不分年轻代和老年代，而是划分成多个 Region，每个Region都被定义为 Eden 区 或者 Survivor区 或者 Old区
  \- 优先清理垃圾最多的区域
  \- STW 停顿的时间和分布可预期且可配置
  \- 每次 GC 都不必去收集整个堆空间，而是只处理一部分内存块
  \- 当堆的整个内存空间不足，并且发生Full GC时，它可能会退化为使用 Serial 来进行垃圾收集
  \- 适合多核 CPU 的服务器上，并且堆内存非常充足的应用
- -XX:+UseG1GC  -XX:MaxGCPauseMillis=100，将 STW 停顿的时间和分布，变成可预期且可配置的， G1回收 不必每次都去收集整个堆空间，每次只处理一部分内存块，叫做 GC 的回收集 (Collection set)，每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块，G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。